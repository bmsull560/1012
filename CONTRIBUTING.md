# Contributing to ValueVerse

Thank you for your interest in contributing to the ValueVerse Platform! This document provides guidelines and standards for contributing to the project.

## Table of Contents

- [Code of Conduct](#code-of-conduct)
- [Development Standards](#development-standards)
- [Getting Started](#getting-started)
- [Development Workflow](#development-workflow)
- [Code Quality Requirements](#code-quality-requirements)
- [Security Guidelines](#security-guidelines)
- [Testing Requirements](#testing-requirements)
- [Documentation](#documentation)
- [Pull Request Process](#pull-request-process)

## Code of Conduct

We are committed to providing a welcoming and inclusive environment. All contributors are expected to:

- Be respectful and constructive in communication
- Accept constructive criticism gracefully
- Focus on what is best for the community and project
- Show empathy towards other community members

## Development Standards

ValueVerse follows enterprise-grade development standards based on five core principles:

### 1. Security by Design

Security is not an afterthoughtâ€”it's foundational:

- **Input Validation**: All untrusted data must be validated and sanitized (use Pydantic for backend, Zod for frontend)
- **Authentication**: OAuth 2.0 + OIDC with JWT tokens
- **Authorization**: RBAC with Principle of Least Privilege
- **Encryption**: TLS 1.3 in transit, AES-256-GCM at rest
- **Secrets Management**: Never commit secrets; use environment variables

### 2. Production-Grade Code Quality

Code must be maintainable and clear:

- **Readability**: Self-documenting code with descriptive names
- **Modularity**: Single-responsibility functions and classes
- **Error Handling**: Comprehensive with proper logging
- **Testing**: 80%+ code coverage (100% for critical paths)

### 3. Resilient and Scalable Architecture

Design for scale from day one:

- **API-First**: All services expose versioned, documented APIs
- **Stateless Services**: Enable horizontal scaling
- **Asynchronous Communication**: Use message queues for non-critical tasks

### 4. Rigorous AI Agent Collaboration

All AI-generated code must be:

- Thoroughly reviewed by a human developer
- Understood completely before committing
- Tested to the same standards as human-written code
- Documented with clear explanations

### 5. Continuous Integration and Delivery

Automation ensures quality:

- All commits trigger automated CI/CD pipeline
- Tests must pass before merging
- Code coverage cannot decrease
- Security scans must show no high-severity issues

## Getting Started

### Prerequisites

1. **Development Environment**: VS Code with Dev Containers extension
2. **Docker Desktop**: 8GB RAM recommended
3. **Git**: Version control
4. **API Keys**: OpenAI, Anthropic (for AI features)

### Initial Setup

```bash
# Clone the repository
git clone <repository-url>
cd 1012

# Open in VS Code
code .

# Reopen in Dev Container (when prompted)
# Or: F1 â†’ "Dev Containers: Reopen in Container"

# Wait for container build (first time: 3-5 minutes)
```

### Verify Setup

```bash
# Backend
cd backend
python --version  # Should be 3.11+
pytest            # Should pass (when tests exist)

# Frontend
cd frontend
node --version    # Should be 22+
npm test          # Should pass (when tests exist)
```

## Development Workflow

### Branch Strategy

- `main`: Production-ready code (protected)
- `develop`: Integration branch for features
- `feature/*`: Individual features
- `bugfix/*`: Bug fixes
- `hotfix/*`: Production hotfixes

### Creating a Feature

```bash
# Create feature branch from develop
git checkout develop
git pull origin develop
git checkout -b feature/your-feature-name

# Make changes and commit frequently
git add .
git commit -m "feat: descriptive commit message"

# Push to remote
git push origin feature/your-feature-name

# Create Pull Request on GitHub
```

### Commit Message Format

Follow conventional commits:

```
type(scope): subject

body (optional)

footer (optional)
```

**Types**:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting)
- `refactor`: Code refactoring
- `test`: Adding or updating tests
- `chore`: Maintenance tasks

**Examples**:
```
feat(agents): implement Value Architect agent
fix(api): handle null values in value graph queries
docs(readme): update installation instructions
```

## Code Quality Requirements

### Python (Backend)

```bash
# Format code
black .
isort .

# Lint
flake8 .

# Type check
mypy .

# Tests
pytest --cov=app --cov-report=html
```

**Standards**:
- Follow PEP 8
- Use type hints for all functions
- Maximum line length: 88 characters (Black default)
- Docstrings for all public functions and classes

**Example**:
```python
from typing import Optional
from pydantic import BaseModel

class ValueHypothesis(BaseModel):
    """Represents a value hypothesis generated by the Value Architect agent.
    
    Attributes:
        id: Unique identifier for the hypothesis
        customer_id: Associated customer identifier
        value_drivers: List of identified value drivers
        confidence: Confidence score (0.0 to 1.0)
    """
    id: str
    customer_id: str
    value_drivers: list[str]
    confidence: float
    
    def validate_confidence(self) -> None:
        """Ensures confidence score is within valid range."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
```

### TypeScript (Frontend)

```bash
# Format code
npm run format

# Lint
npm run lint

# Type check
npm run type-check

# Tests
npm test
```

**Standards**:
- Strict TypeScript mode enabled
- Use functional components with hooks
- Prefer composition over inheritance
- Avoid `any` type; use proper typing

**Example**:
```typescript
import { useState, useCallback } from 'react'

interface ValueDriver {
  id: string
  name: string
  impact: number
  confidence: number
}

interface ValueDriverCardProps {
  driver: ValueDriver
  onSelect: (id: string) => void
}

export function ValueDriverCard({ driver, onSelect }: ValueDriverCardProps) {
  const [isHovered, setIsHovered] = useState(false)
  
  const handleClick = useCallback(() => {
    onSelect(driver.id)
  }, [driver.id, onSelect])
  
  return (
    <div 
      className="border rounded-lg p-4 cursor-pointer"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={handleClick}
    >
      <h3 className="font-semibold">{driver.name}</h3>
      <p>Impact: ${driver.impact.toLocaleString()}</p>
      <p>Confidence: {(driver.confidence * 100).toFixed(0)}%</p>
    </div>
  )
}
```

## Security Guidelines

### Input Validation

**Backend (Pydantic)**:
```python
from pydantic import BaseModel, Field, validator

class CustomerInput(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    email: str = Field(..., regex=r'^[\w\.-]+@[\w\.-]+\.\w+$')
    budget: float = Field(..., gt=0, le=1_000_000_000)
    
    @validator('name')
    def sanitize_name(cls, v):
        # Remove any HTML/script tags
        return v.strip()
```

**Frontend (Zod)**:
```typescript
import { z } from 'zod'

const customerSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email(),
  budget: z.number().positive().max(1_000_000_000),
})

type Customer = z.infer<typeof customerSchema>
```

### Authentication

Never bypass authentication checks:

```python
# âŒ Wrong
@app.get("/sensitive-data")
async def get_data():
    return {"data": "sensitive"}

# âœ… Correct
@app.get("/sensitive-data")
async def get_data(current_user: User = Depends(get_current_user)):
    return {"data": "sensitive"}
```

### Secrets Management

```bash
# âŒ Never commit secrets
AWS_ACCESS_KEY=AKIAIOSFODNN7EXAMPLE

# âœ… Use environment variables
AWS_ACCESS_KEY=${AWS_ACCESS_KEY}
```

## Testing Requirements

### Test Coverage

- Minimum 80% code coverage overall
- 100% coverage for:
  - Security-critical paths
  - Business logic
  - Value calculation algorithms

### Test Types

**Unit Tests**: Test individual functions/components
```python
def test_value_calculation():
    result = calculate_roi(
        investment=100_000,
        annual_savings=30_000,
        years=3
    )
    assert result.roi == 0.9  # 90% ROI over 3 years
    assert result.payback_period == 3.33
```

**Integration Tests**: Test component interactions
```python
@pytest.mark.integration
async def test_agent_orchestration():
    architect = ValueArchitect()
    hypothesis = await architect.define_value(deal_context)
    
    committer = ValueCommitter()
    commitment = await committer.commit_to_value(hypothesis)
    
    assert commitment.hypothesis_id == hypothesis.id
```

**E2E Tests**: Test complete user workflows
```typescript
test('user can build value model', async ({ page }) => {
  await page.goto('/pre-sales')
  await page.click('text=Build Value Model')
  await page.fill('[name="company"]', 'Acme Corp')
  await page.click('text=Start')
  
  await expect(page.locator('.value-hypothesis')).toBeVisible()
})
```

## Documentation

### Code Documentation

- All public APIs must have docstrings/JSDoc
- Complex algorithms need explanatory comments
- Include examples in documentation

### Architecture Documentation

When making architectural changes:

1. Update relevant files in `/docs`
2. Add diagrams if helpful (Mermaid or PlantUML)
3. Document trade-offs and alternatives considered

## Pull Request Process

### Before Submitting

- [ ] Code follows style guidelines
- [ ] All tests pass locally
- [ ] Code coverage meets requirements (80%+)
- [ ] No linting errors
- [ ] Security scan passes
- [ ] Documentation updated
- [ ] Commit messages follow convention

### PR Description Template

```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated
- [ ] E2E tests added/updated
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] No new warnings
- [ ] Tests pass locally
```

### Review Process

1. **Automated Checks**: CI/CD pipeline runs automatically
2. **Code Review**: At least one approval required
3. **Security Review**: For security-sensitive changes
4. **Testing**: QA validation for major features
5. **Merge**: Squash and merge to keep history clean

### Merging

- Use "Squash and merge" for feature branches
- Delete branch after merging
- Ensure linear history on main branch

## Getting Help

- **Documentation**: Check `/docs` directory
- **Issues**: Search existing issues before creating new ones
- **Discussions**: Use GitHub Discussions for questions
- **Slack**: Internal team channel for real-time help

## Recognition

Contributors will be recognized in:
- Release notes
- Contributors section in README
- Annual contributor acknowledgments

---

Thank you for contributing to ValueVerse! Your efforts help build the future of value realization. ðŸš€
