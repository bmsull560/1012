#!/bin/bash

# Penetration Testing Script for Staging Environment
# Runs comprehensive security tests using OWASP ZAP, Nuclei, and custom scripts

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
STAGING_URL="${STAGING_URL:-https://staging.valueverse.ai}"
REPORT_DIR="./pentest-reports/$(date +%Y%m%d-%H%M%S)"
TENANT_A_TOKEN=""
TENANT_B_TOKEN=""

# Create report directory
mkdir -p "${REPORT_DIR}"

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
log_test() { echo -e "${BLUE}[TEST]${NC} $1"; }

# Get test tokens for different tenants
setup_test_tokens() {
    log_info "Setting up test tokens..."
    
    # Get Tenant A token
    TENANT_A_TOKEN=$(curl -s -X POST "${STAGING_URL}/api/auth/login" \
        -H "Content-Type: application/json" \
        -d '{"email":"test-a@valueverse.ai","password":"TestPassword123!"}' \
        | jq -r '.access_token')
    
    # Get Tenant B token
    TENANT_B_TOKEN=$(curl -s -X POST "${STAGING_URL}/api/auth/login" \
        -H "Content-Type: application/json" \
        -d '{"email":"test-b@valueverse.ai","password":"TestPassword456!"}' \
        | jq -r '.access_token')
    
    if [ -z "$TENANT_A_TOKEN" ] || [ -z "$TENANT_B_TOKEN" ]; then
        log_error "Failed to get test tokens"
        exit 1
    fi
    
    log_info "Test tokens acquired ✓"
}

# OWASP ZAP Security Scan
run_zap_scan() {
    log_test "Running OWASP ZAP security scan..."
    
    docker run --rm -v "${PWD}/${REPORT_DIR}:/zap/reports:rw" \
        -t owasp/zap2docker-stable zap-full-scan.py \
        -t "${STAGING_URL}" \
        -r zap-report.html \
        -x zap-report.xml \
        -J zap-report.json \
        -a -j \
        --hook=/zap/auth-hook.py \
        -z "auth.loginurl=${STAGING_URL}/api/auth/login \
            auth.username=test-a@valueverse.ai \
            auth.password=TestPassword123! \
            auth.auto=1"
    
    log_info "ZAP scan completed. Report: ${REPORT_DIR}/zap-report.html"
}

# Nuclei Security Templates
run_nuclei_scan() {
    log_test "Running Nuclei security templates..."
    
    docker run --rm -v "${PWD}/${REPORT_DIR}:/reports" \
        projectdiscovery/nuclei:latest \
        -u "${STAGING_URL}" \
        -t cves/ -t vulnerabilities/ -t misconfiguration/ \
        -severity critical,high,medium \
        -o /reports/nuclei-report.txt \
        -json -je /reports/nuclei-report.json \
        -H "Authorization: Bearer ${TENANT_A_TOKEN}"
    
    log_info "Nuclei scan completed. Report: ${REPORT_DIR}/nuclei-report.txt"
}

# SQL Injection Testing
test_sql_injection() {
    log_test "Testing SQL injection vulnerabilities..."
    
    local endpoints=(
        "/api/invoices/1"
        "/api/customers/search"
        "/api/subscriptions/filter"
    )
    
    local payloads=(
        "1' OR '1'='1"
        "1; DROP TABLE users--"
        "1 UNION SELECT * FROM information_schema.tables"
        "admin'--"
        "' OR 1=1--"
        "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--"
    )
    
    echo "# SQL Injection Test Results" > "${REPORT_DIR}/sql-injection.md"
    
    for endpoint in "${endpoints[@]}"; do
        echo "## Testing ${endpoint}" >> "${REPORT_DIR}/sql-injection.md"
        
        for payload in "${payloads[@]}"; do
            response=$(curl -s -o /dev/null -w "%{http_code}" \
                -H "Authorization: Bearer ${TENANT_A_TOKEN}" \
                "${STAGING_URL}${endpoint}?id=${payload}")
            
            if [ "$response" -eq 500 ]; then
                echo "⚠️  POTENTIAL VULNERABILITY: ${endpoint} with payload: ${payload}" >> "${REPORT_DIR}/sql-injection.md"
                log_warn "Potential SQL injection at ${endpoint}"
            else
                echo "✓ Protected: ${endpoint} returned ${response} for payload: ${payload}" >> "${REPORT_DIR}/sql-injection.md"
            fi
        done
    done
    
    log_info "SQL injection tests completed"
}

# Cross-Site Scripting (XSS) Testing
test_xss() {
    log_test "Testing XSS vulnerabilities..."
    
    local payloads=(
        "<script>alert('XSS')</script>"
        "javascript:alert('XSS')"
        "<img src=x onerror=alert('XSS')>"
        "<svg onload=alert('XSS')>"
        "';alert('XSS');//"
    )
    
    echo "# XSS Test Results" > "${REPORT_DIR}/xss-test.md"
    
    for payload in "${payloads[@]}"; do
        # Test in various input fields
        response=$(curl -s -X POST "${STAGING_URL}/api/customers" \
            -H "Authorization: Bearer ${TENANT_A_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{\"name\":\"${payload}\",\"email\":\"test@example.com\"}")
        
        if echo "$response" | grep -q "$payload"; then
            echo "⚠️  POTENTIAL XSS: Unescaped payload in response: ${payload}" >> "${REPORT_DIR}/xss-test.md"
            log_warn "Potential XSS vulnerability detected"
        else
            echo "✓ Protected: Payload properly escaped: ${payload}" >> "${REPORT_DIR}/xss-test.md"
        fi
    done
    
    log_info "XSS tests completed"
}

# Multi-Tenant Isolation Testing
test_tenant_isolation() {
    log_test "Testing multi-tenant isolation..."
    
    echo "# Tenant Isolation Test Results" > "${REPORT_DIR}/tenant-isolation.md"
    
    # Create resource as Tenant A
    resource_a=$(curl -s -X POST "${STAGING_URL}/api/invoices" \
        -H "Authorization: Bearer ${TENANT_A_TOKEN}" \
        -H "Content-Type: application/json" \
        -d '{"customer_id":"cust-a","amount":1000,"description":"Tenant A Invoice"}' \
        | jq -r '.id')
    
    # Try to access Tenant A's resource as Tenant B
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer ${TENANT_B_TOKEN}" \
        "${STAGING_URL}/api/invoices/${resource_a}")
    
    if [ "$response" -eq 404 ]; then
        echo "✓ PASSED: Tenant B cannot access Tenant A's invoice (404)" >> "${REPORT_DIR}/tenant-isolation.md"
        log_info "Tenant isolation test PASSED ✓"
    else
        echo "⚠️  FAILED: Tenant B got response ${response} for Tenant A's invoice" >> "${REPORT_DIR}/tenant-isolation.md"
        log_error "Tenant isolation test FAILED!"
    fi
    
    # Test header spoofing
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer ${TENANT_A_TOKEN}" \
        -H "X-Tenant-ID: tenant-b-id" \
        "${STAGING_URL}/api/invoices")
    
    if [ "$response" -eq 403 ]; then
        echo "✓ PASSED: Header spoofing prevented (403)" >> "${REPORT_DIR}/tenant-isolation.md"
    else
        echo "⚠️  WARNING: Header spoofing returned ${response}" >> "${REPORT_DIR}/tenant-isolation.md"
    fi
}

# Authentication & Authorization Testing
test_auth() {
    log_test "Testing authentication and authorization..."
    
    echo "# Authentication Test Results" > "${REPORT_DIR}/auth-test.md"
    
    # Test expired token
    expired_token="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MDAwMDAwMDB9.invalid"
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer ${expired_token}" \
        "${STAGING_URL}/api/invoices")
    
    if [ "$response" -eq 401 ]; then
        echo "✓ PASSED: Expired token rejected (401)" >> "${REPORT_DIR}/auth-test.md"
    else
        echo "⚠️  FAILED: Expired token returned ${response}" >> "${REPORT_DIR}/auth-test.md"
    fi
    
    # Test missing token
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        "${STAGING_URL}/api/invoices")
    
    if [ "$response" -eq 401 ]; then
        echo "✓ PASSED: Missing token rejected (401)" >> "${REPORT_DIR}/auth-test.md"
    else
        echo "⚠️  FAILED: Missing token returned ${response}" >> "${REPORT_DIR}/auth-test.md"
    fi
    
    # Test invalid signature
    invalid_token="${TENANT_A_TOKEN}tampered"
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: Bearer ${invalid_token}" \
        "${STAGING_URL}/api/invoices")
    
    if [ "$response" -eq 401 ]; then
        echo "✓ PASSED: Invalid signature rejected (401)" >> "${REPORT_DIR}/auth-test.md"
    else
        echo "⚠️  FAILED: Invalid signature returned ${response}" >> "${REPORT_DIR}/auth-test.md"
    fi
    
    log_info "Authentication tests completed"
}

# Rate Limiting Testing
test_rate_limiting() {
    log_test "Testing rate limiting..."
    
    echo "# Rate Limiting Test Results" > "${REPORT_DIR}/rate-limit.md"
    
    # Send 150 requests rapidly (limit should be 100/min)
    for i in {1..150}; do
        response=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${TENANT_A_TOKEN}" \
            "${STAGING_URL}/api/invoices")
        
        if [ "$response" -eq 429 ]; then
            echo "✓ PASSED: Rate limit enforced at request ${i} (429)" >> "${REPORT_DIR}/rate-limit.md"
            log_info "Rate limiting working at request ${i} ✓"
            break
        fi
        
        if [ "$i" -eq 150 ]; then
            echo "⚠️  FAILED: No rate limiting after 150 requests" >> "${REPORT_DIR}/rate-limit.md"
            log_warn "Rate limiting may not be working"
        fi
    done
}

# CSRF Testing
test_csrf() {
    log_test "Testing CSRF protection..."
    
    echo "# CSRF Test Results" > "${REPORT_DIR}/csrf-test.md"
    
    # Try POST without CSRF token
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        -X POST "${STAGING_URL}/api/invoices" \
        -H "Authorization: Bearer ${TENANT_A_TOKEN}" \
        -H "Content-Type: application/json" \
        -H "Origin: https://evil-site.com" \
        -d '{"customer_id":"test","amount":1000}')
    
    if [ "$response" -eq 403 ]; then
        echo "✓ PASSED: CSRF protection active (403)" >> "${REPORT_DIR}/csrf-test.md"
        log_info "CSRF protection working ✓"
    else
        echo "⚠️  WARNING: Cross-origin POST returned ${response}" >> "${REPORT_DIR}/csrf-test.md"
    fi
}

# Security Headers Testing
test_security_headers() {
    log_test "Testing security headers..."
    
    echo "# Security Headers Test Results" > "${REPORT_DIR}/headers-test.md"
    
    headers=$(curl -s -I "${STAGING_URL}")
    
    # Check required security headers
    required_headers=(
        "Strict-Transport-Security"
        "X-Content-Type-Options: nosniff"
        "X-Frame-Options: DENY"
        "Content-Security-Policy"
        "X-XSS-Protection"
    )
    
    for header in "${required_headers[@]}"; do
        if echo "$headers" | grep -qi "$header"; then
            echo "✓ PASSED: ${header} present" >> "${REPORT_DIR}/headers-test.md"
        else
            echo "⚠️  MISSING: ${header}" >> "${REPORT_DIR}/headers-test.md"
            log_warn "Missing security header: ${header}"
        fi
    done
    
    log_info "Security headers test completed"
}

# Generate final report
generate_pentest_report() {
    log_info "Generating penetration test report..."
    
    cat <<EOF > "${REPORT_DIR}/pentest-summary.md"
# Penetration Test Report

**Date:** $(date)
**Target:** ${STAGING_URL}
**Environment:** Staging

## Executive Summary

This penetration test was conducted on the ValueVerse staging environment to identify security vulnerabilities before production deployment.

## Test Results

### Critical Findings
$(grep -h "FAILED" ${REPORT_DIR}/*.md 2>/dev/null | wc -l) critical issues found

### High Priority Findings
$(grep -h "WARNING" ${REPORT_DIR}/*.md 2>/dev/null | wc -l) warnings found

### Tests Passed
$(grep -h "PASSED" ${REPORT_DIR}/*.md 2>/dev/null | wc -l) tests passed

## Detailed Results

### 1. SQL Injection
$(head -n 5 ${REPORT_DIR}/sql-injection.md 2>/dev/null || echo "No SQL injection vulnerabilities found")

### 2. Cross-Site Scripting (XSS)
$(head -n 5 ${REPORT_DIR}/xss-test.md 2>/dev/null || echo "No XSS vulnerabilities found")

### 3. Tenant Isolation
$(grep "PASSED\|FAILED" ${REPORT_DIR}/tenant-isolation.md 2>/dev/null || echo "Tenant isolation tests pending")

### 4. Authentication & Authorization
$(grep "PASSED\|FAILED" ${REPORT_DIR}/auth-test.md 2>/dev/null || echo "Auth tests pending")

### 5. Rate Limiting
$(grep "PASSED\|FAILED" ${REPORT_DIR}/rate-limit.md 2>/dev/null || echo "Rate limiting tests pending")

### 6. CSRF Protection
$(grep "PASSED\|FAILED" ${REPORT_DIR}/csrf-test.md 2>/dev/null || echo "CSRF tests pending")

### 7. Security Headers
$(grep "PASSED\|MISSING" ${REPORT_DIR}/headers-test.md 2>/dev/null || echo "Headers tests pending")

## Recommendations

1. Review and fix any FAILED tests before production
2. Investigate WARNING items for potential improvements
3. Ensure all security headers are properly configured
4. Verify rate limiting is appropriate for production load
5. Confirm tenant isolation is bulletproof

## Compliance Status

- [ ] OWASP Top 10 addressed
- [ ] PCI DSS requirements met
- [ ] GDPR compliance verified
- [ ] SOC2 controls validated

## Sign-off

- [ ] Security Team Approval
- [ ] DevOps Team Approval
- [ ] Product Owner Approval

EOF
    
    log_info "Penetration test report generated: ${REPORT_DIR}/pentest-summary.md"
}

# Main execution
main() {
    log_info "Starting penetration testing on ${STAGING_URL}..."
    
    setup_test_tokens
    
    # Run all security tests
    run_zap_scan
    run_nuclei_scan
    test_sql_injection
    test_xss
    test_tenant_isolation
    test_auth
    test_rate_limiting
    test_csrf
    test_security_headers
    
    # Generate report
    generate_pentest_report
    
    log_info "🔒 Penetration testing completed!"
    log_info "Reports saved to: ${REPORT_DIR}"
    
    # Check for critical issues
    if grep -q "FAILED" "${REPORT_DIR}"/*.md 2>/dev/null; then
        log_error "⚠️  Critical security issues found! Review reports before production deployment."
        exit 1
    else
        log_info "✅ No critical security issues found. Ready for load testing."
    fi
}

# Run main function
main "$@"
